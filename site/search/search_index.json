{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"ManimGL Documentation","text":"<p>This document provides a focused guide to the most essential components of ManimGL (the 3b1b version). It is designed for both beginners and intermediate users, prioritizing the APIs and concepts needed for the majority of animation projects.</p>"},{"location":"#getting-started","title":"Getting Started","text":"<ul> <li>Quick Reference - Essential classes, workflow, and typical scene structure</li> <li>Core Concepts - Understanding Mobjects, Animations, and Scenes</li> <li>Common Patterns - Practical examples and gotchas</li> <li>Use Case Index - Find what you need by what you want to do</li> </ul>"},{"location":"#api-reference","title":"API Reference","text":""},{"location":"#scenes","title":"Scenes","text":"<ul> <li>Scene - The base class for all animations</li> </ul>"},{"location":"#mobjects","title":"Mobjects","text":"<ul> <li>Geometry - Circle, Square, Rectangle, Line, Arrow, Dot</li> <li>Text &amp; Math - Text, Tex, MathTex</li> <li>Grouping - VGroup</li> <li>Utilities - ValueTracker</li> </ul>"},{"location":"#animations","title":"Animations","text":"<ul> <li>Creation - Create, Write, DrawBorderThenFill</li> <li>Transformation - Transform, ReplacementTransform, ApplyMethod</li> <li>Fading - FadeIn, FadeOut</li> <li>Composition - AnimationGroup, Succession, LaggedStart</li> </ul>"},{"location":"#utilities","title":"Utilities","text":"<ul> <li>Rate Functions - smooth, linear, there_and_back, etc.</li> </ul>"},{"location":"core-concepts/","title":"Core Concepts","text":""},{"location":"core-concepts/#what-is-a-mobject","title":"What is a Mobject?","text":"<p>A Mobject (short for Mathematical Object) is the fundamental building block for everything you see on screen. Shapes, lines, text, and even complex graphs are all types of Mobjects.</p> <ul> <li>They have properties you can change, like <code>color</code>, <code>opacity</code>, position, and scale.</li> <li>They can be combined into groups using <code>Group</code> or <code>VGroup</code>.</li> <li>Most mobjects you'll use are <code>VMobject</code>s (Vectorized Mobjects), which are defined by points and curves. This means they can be scaled infinitely without losing quality and can be smoothly transformed.</li> </ul>"},{"location":"core-concepts/#what-is-an-animation","title":"What is an Animation?","text":"<p>An Animation is a command that tells a <code>Mobject</code> how to change over a period of time. You don't create an animation and then run it; instead, you pass an <code>Animation</code> instance directly into the <code>Scene.play()</code> method.</p> <ul> <li>Examples include <code>Create</code> (to draw a mobject), <code>Transform</code> (to morph one mobject into another), and <code>FadeIn</code> (to make a mobject appear).</li> <li>Animations have a default <code>run_time</code> of 1 second, which can be overridden in <code>self.play(..., run_time=2)</code>.</li> <li>Multiple animations can be played simultaneously by passing them all into the same <code>self.play()</code> call.</li> </ul>"},{"location":"core-concepts/#what-is-a-scene","title":"What is a Scene?","text":"<p>A Scene is the canvas and timeline for your animation. Your script will consist of one or more classes that inherit from <code>Scene</code>.</p> <ul> <li>The main logic of your animation is written in the <code>construct</code> method.</li> <li>The <code>Scene</code> object keeps track of all mobjects that are currently on screen.</li> <li>It provides the essential methods for controlling the animation timeline: <code>play()</code>, <code>wait()</code>, <code>add()</code>, and <code>remove()</code>.</li> </ul>"},{"location":"core-concepts/#how-they-work-together","title":"How They Work Together","text":"<p>You create <code>Mobject</code>s, add them to the <code>Scene</code>, and then use <code>Animation</code>s inside <code>self.play()</code> to bring them to life. The <code>Scene</code> orchestrates the rendering of each frame as the animations progress.</p>"},{"location":"patterns/","title":"Common Patterns","text":""},{"location":"patterns/#animating-with-animate","title":"Animating with <code>.animate</code>","text":"<p>For simple transformations like moving, scaling, or color-changing, the <code>.animate</code> syntax is a powerful and readable shortcut. Instead of creating a <code>Transform</code> object manually, you call <code>.animate</code> on your mobject and then call the method you want to animate.</p> <p>How it works: <code>my_mobject.animate.shift(UP)</code> creates a copy of <code>my_mobject</code>, applies <code>.shift(UP)</code> to the copy to create a <code>target</code>, and then generates a <code>MoveToTarget</code> animation from the original to the target.</p> <p>Example:</p> <pre><code># Instead of this:\ntarget_square = square.copy().shift(UP).set_color(BLUE)\nself.play(Transform(square, target_square))\n\n# You can do this:\nself.play(square.animate.shift(UP).set_color(BLUE))\n</code></pre>"},{"location":"patterns/#positioning-mobjects","title":"Positioning Mobjects","text":"<p>Mobjects have several methods for precise positioning relative to other objects or the screen.</p> <ul> <li><code>.move_to(point_or_mobject)</code>: Moves the mobject's center to a specific point or another mobject's center.</li> <li><code>.next_to(other_mobject, direction, buff=0.25)</code>: Places the mobject next to another one in a given direction (e.g., <code>UP</code>, <code>RIGHT</code>).</li> <li><code>.to_edge(edge, buff=0.5)</code>: Aligns the mobject to an edge of the screen (e.g., <code>UP</code>, <code>LEFT</code>).</li> <li><code>.to_corner(corner, buff=0.5)</code>: Aligns the mobject to a corner of the screen (e.g., <code>UL</code>, <code>DR</code>).</li> <li><code>.center()</code>: Moves the mobject to the center of the screen, <code>(0, 0, 0)</code>.</li> </ul>"},{"location":"patterns/#using-updaters-with-valuetracker","title":"Using Updaters with <code>ValueTracker</code>","text":"<p>For animations that need to run continuously or respond to a changing value, updaters are essential. An updater is a function that is called on every frame.</p> <p>Pattern: 1.  Create a <code>ValueTracker</code> to hold the value you want to animate. 2.  Create a mobject whose properties depend on this value. 3.  Add an updater function to the mobject using <code>.add_updater()</code>. The function should read the value from the <code>ValueTracker</code> and update the mobject. 4.  Animate the <code>ValueTracker</code> using <code>self.play(my_tracker.animate.set_value(new_value))</code>.</p> <p>Example:</p> <pre><code># Animate a line rotating based on a value\nangle_tracker = ValueTracker(0)\nline = Line(ORIGIN, RIGHT * 2)\nline.add_updater(\n    lambda m: m.set_angle(angle_tracker.get_value())\n)\nself.add(line)\nself.play(angle_tracker.animate.set_value(PI)) # Rotates 180 degrees\n</code></pre>"},{"location":"patterns/#common-gotchas","title":"Common Gotchas","text":"<ul> <li><code>Transform</code> vs. <code>ReplacementTransform</code>: <code>Transform</code> modifies the original mobject. <code>ReplacementTransform</code> swaps it for the target. If your object \"disappears\" after a transform, you probably wanted <code>ReplacementTransform</code>.</li> <li>Modifying an object vs. Animating it: Calling a method like <code>my_mobject.shift(UP)</code> teleports the object instantly. To animate the change, you must wrap it in an animation, like <code>self.play(my_mobject.animate.shift(UP))</code>.</li> <li>Forgetting to <code>add</code>: If you want an object to be on screen before it is animated, you must first <code>self.add(my_mobject)</code> and then <code>self.wait()</code> or <code>self.play(...)</code>.</li> </ul>"},{"location":"quick-reference/","title":"Quick Reference","text":""},{"location":"quick-reference/#core-components-overview","title":"Core Components Overview","text":"<p>Manim animations are built from three fundamental components:</p> <ul> <li><code>Mobject</code>: The visual objects that appear on screen (e.g., shapes, text, graphs).</li> <li><code>Animation</code>: Instructions for how <code>Mobject</code>s should change over time (e.g., appear, transform, move).</li> <li><code>Scene</code>: The canvas where <code>Mobject</code>s are placed and <code>Animation</code>s are played out.</li> </ul>"},{"location":"quick-reference/#most-important-classes-by-category","title":"Most Important Classes by Category","text":"<ul> <li>Scenes: <code>Scene</code></li> <li>Mobjects (Shapes): <code>Circle</code>, <code>Square</code>, <code>Line</code>, <code>Arrow</code>, <code>Dot</code>, <code>Polygon</code></li> <li>Mobjects (Text &amp; Math): <code>Text</code>, <code>Tex</code>, <code>MathTex</code></li> <li>Mobjects (Grouping): <code>VGroup</code></li> <li>Animations (Creation): <code>Create</code>, <code>Write</code>, <code>DrawBorderThenFill</code></li> <li>Animations (Transformation): <code>Transform</code>, <code>ReplacementTransform</code>, <code>ApplyMethod</code></li> <li>Animations (Visibility): <code>FadeIn</code>, <code>FadeOut</code></li> <li>Animations (Composition): <code>AnimationGroup</code>, <code>Succession</code>, <code>LaggedStart</code></li> <li>Utilities: <code>ValueTracker</code>, rate functions (<code>smooth</code>, <code>linear</code>, <code>there_and_back</code>)</li> </ul>"},{"location":"quick-reference/#typical-scene-structure","title":"Typical Scene Structure","text":"<p>Almost every Manim script follows this structure. You create a class that inherits from <code>Scene</code> and define your animation sequence inside the <code>construct</code> method.</p> <pre><code>from manimlib import *\n\nclass MyAwesomeAnimation(Scene):\n    def construct(self):\n        # 1. Create Mobjects\n        circle = Circle()\n        square = Square()\n\n        # 2. Add Mobjects to the scene\n        self.add(circle)\n\n        # 3. Animate Mobjects using self.play()\n        self.play(Transform(circle, square))\n        self.play(FadeOut(square))\n\n        # 4. Wait for a moment\n        self.wait(1)\n</code></pre>"},{"location":"quick-reference/#essential-workflow","title":"Essential Workflow","text":"<ol> <li>Define a Scene: Create a class inheriting from <code>Scene</code>.</li> <li>Create Mobjects: Inside <code>construct</code>, instantiate shapes, text, or other visual elements (<code>Circle</code>, <code>Text</code>, etc.).</li> <li>Position Mobjects: Use methods like <code>.move_to()</code>, <code>.next_to()</code>, and <code>.to_edge()</code> to place your mobjects.</li> <li>Animate Mobjects: Call <code>self.play()</code> and pass in one or more <code>Animation</code> classes (e.g., <code>self.play(Create(my_shape))</code>).</li> <li>Use <code>.animate</code> for simplicity: For simple property changes, use the <code>.animate</code> syntax: <code>self.play(my_mobject.animate.shift(UP))</code>.</li> </ol>"},{"location":"scenes/","title":"Scenes","text":"<p>This category covers the main environment in which animations are created and played.</p>"},{"location":"scenes/#scene","title":"<code>Scene</code>","text":"<p>Purpose: The base class for all animations; it represents the screen and timeline.</p> <p>Common Use Cases: - Creating any Manim animation by subclassing it. - Using its methods to control the flow of the animation.</p> <p>When to Use:  Always. Every animation script requires a class that inherits from <code>Scene</code>.</p>"},{"location":"scenes/#key-methods","title":"Key Methods","text":"<pre><code>play(self, *proto_animations: Animation | _AnimationBuilder, run_time: float | None = None, rate_func: Callable[[float], float] | None = None, lag_ratio: float | None = None) -&gt; None\n</code></pre> <p>Plays one or more animations. This is the primary method for creating movement and change in your scene. It waits for the animations to complete before proceeding. - <code>proto_animations</code>: One or more animation objects (e.g., <code>Create(my_mobject)</code>, <code>my_mobject.animate.shift(UP)</code>). - <code>run_time</code>: The duration of the animation in seconds. If not specified, it defaults to the <code>run_time</code> of the animation object, which is typically 1 second. - <code>rate_func</code>: A function that controls the speed of the animation over its duration (e.g., <code>smooth</code>, <code>linear</code>).</p> <pre><code>wait(self, duration: float | None = None, stop_condition: Callable[[], bool] | None = None) -&gt; None\n</code></pre> <p>Pauses the scene for a specified duration. - <code>duration</code>: Time to wait in seconds. Defaults to <code>1.0</code>.</p> <pre><code>add(self, *mobjects: Mobject) -&gt; None\n</code></pre> <p>Adds one or more mobjects to the scene, making them visible in subsequent frames. Mobjects added this way are static until animated.</p> <pre><code>remove(self, *mobjects: Mobject) -&gt; None\n</code></pre> <p>Removes one or more mobjects from the scene, making them invisible.</p>"},{"location":"use-case-index/","title":"Index by Use Case","text":"<p>\"I want to...\"</p> <ul> <li>...draw a shape or path on screen.<ul> <li>Use <code>self.play(Create(my_shape))</code></li> </ul> </li> <li>...write text or a formula.<ul> <li>Use <code>self.play(Write(my_text))</code></li> </ul> </li> <li>...make an object appear instantly.<ul> <li>Use <code>self.add(my_object)</code></li> </ul> </li> <li>...make an object fade in or out.<ul> <li>Use <code>self.play(FadeIn(my_object))</code> or <code>self.play(FadeOut(my_object))</code></li> </ul> </li> <li>...move an object.<ul> <li>Use <code>self.play(my_object.animate.shift(direction))</code></li> <li>Use <code>self.play(my_object.animate.move_to(new_location))</code></li> </ul> </li> <li>...change an object's color.<ul> <li>Use <code>self.play(my_object.animate.set_color(NEW_COLOR))</code></li> </ul> </li> <li>...scale an object.<ul> <li>Use <code>self.play(my_object.animate.scale(2))</code></li> </ul> </li> <li>...morph one shape into another.<ul> <li>Use <code>self.play(Transform(shape1, shape2))</code> if <code>shape1</code> should become <code>shape2</code>.</li> <li>Use <code>self.play(ReplacementTransform(shape1, shape2))</code> if <code>shape1</code> should be replaced by <code>shape2</code>.</li> </ul> </li> <li>...run multiple animations at the same time.<ul> <li>Put them in the same <code>play</code> call: <code>self.play(Animation1(...), Animation2(...))</code></li> </ul> </li> <li>...run animations one after the other.<ul> <li>Put them in separate <code>play</code> calls: <code>self.play(Animation1(...))</code>, <code>self.play(Animation2(...))</code></li> <li>Or use <code>Succession</code>: <code>self.play(Succession(Animation1(...), Animation2(...)))</code></li> </ul> </li> <li>...create a \"ripple\" effect for a group of objects.<ul> <li>Use <code>LaggedStart</code>: <code>self.play(LaggedStart(*(Create(obj) for obj in my_group)))</code></li> </ul> </li> <li>...draw attention to an object.<ul> <li>Use <code>self.play(Indicate(my_object))</code> for a quick bounce and color change.</li> <li>Use <code>self.play(Flash(my_object))</code> for a burst of lines.</li> </ul> </li> <li>...connect an animation to a changing number.<ul> <li>Use a <code>ValueTracker</code> and an updater function.</li> </ul> </li> <li>...pause the animation.<ul> <li>Use <code>self.wait(duration_in_seconds)</code></li> </ul> </li> </ul>"},{"location":"utilities/","title":"Utilities","text":""},{"location":"utilities/#rate-functions","title":"Rate Functions","text":"<p>Rate functions control the speed of an animation over its <code>run_time</code>. They take a time proportion <code>t</code> (from 0 to 1) and return an alpha value (usually 0 to 1) representing the animation's progress. They are passed to <code>play</code> via the <code>rate_func</code> argument.</p>"},{"location":"utilities/#smooth","title":"<code>smooth</code>","text":"<p>Purpose: The default rate function. Starts slow, speeds up in the middle, and ends slow. When to Use: For most natural-looking movements.</p>"},{"location":"utilities/#linear","title":"<code>linear</code>","text":"<p>Purpose: A constant speed throughout the animation. When to Use: For mechanical or uniform processes.</p>"},{"location":"utilities/#rush_into","title":"<code>rush_into</code>","text":"<p>Purpose: Starts fast and slows down at the end. When to Use: For objects quickly arriving at a destination.</p>"},{"location":"utilities/#rush_from","title":"<code>rush_from</code>","text":"<p>Purpose: Starts slow and speeds up at the end. When to Use: For objects quickly departing from a location.</p>"},{"location":"utilities/#there_and_back","title":"<code>there_and_back</code>","text":"<p>Purpose: Animates forward for the first half of the duration and backward for the second half. When to Use: For \"wiggling\" or \"bouncing\" effects, like in the <code>Indicate</code> animation.</p>"},{"location":"animations/composition/","title":"Composition","text":"<p>These classes combine multiple animations to run them together.</p>"},{"location":"animations/composition/#animationgroup","title":"<code>AnimationGroup</code>","text":"<p>Purpose: Plays multiple animations simultaneously.</p> <p>Common Use Cases: - Fading in one object while another transforms. - Creating a complex scene change involving many objects at once.</p> <p>When to Use: Whenever you pass more than one animation into a single <code>self.play()</code> call, you are implicitly using <code>AnimationGroup</code>.</p>"},{"location":"animations/composition/#complete-signature","title":"Complete Signature","text":"<pre><code>AnimationGroup(\n    *animations: Animation,\n    *,\n    run_time: float = -1,\n    lag_ratio: float = 0.0,\n    **kwargs\n)\n</code></pre>"},{"location":"animations/composition/#key-parameters","title":"Key Parameters","text":"<ul> <li><code>animations</code> (Animation): A list of animation objects to play together.</li> <li><code>run_time</code> (float): The total run time for the group. If <code>-1</code>, it defaults to the longest animation's run time.</li> <li><code>lag_ratio</code> (float): A delay factor between the start of each animation in the group. Default is <code>0.0</code> (all start together).</li> </ul> <p>Related: <code>Succession</code>, <code>LaggedStart</code></p>"},{"location":"animations/composition/#succession","title":"<code>Succession</code>","text":"<p>Purpose: Plays multiple animations one after another in a single <code>play</code> call.</p> <p>Common Use Cases: - Creating a sequence of quick, related animations without multiple <code>play</code> calls. - Chaining animations where the end of one is the start of the next.</p> <p>When to Use: When you want to run animations back-to-back within the duration of a single <code>play</code> call. This is different from using multiple <code>play</code> calls, which pauses the script between each call.</p>"},{"location":"animations/composition/#complete-signature_1","title":"Complete Signature","text":"<pre><code>Succession(\n    *animations: Animation,\n    *,\n    lag_ratio: float = 1.0,\n    **kwargs\n)\n</code></pre>"},{"location":"animations/composition/#key-parameters_1","title":"Key Parameters","text":"<ul> <li><code>animations</code> (Animation): The animation objects to play in sequence.</li> <li><code>lag_ratio</code> (float): Set to <code>1.0</code> by default, which means each animation starts only after the previous one has finished.</li> </ul> <p>Related: <code>AnimationGroup</code></p>"},{"location":"animations/composition/#laggedstart","title":"<code>LaggedStart</code>","text":"<p>Purpose: Plays a group of animations with a small delay between the start of each one.</p> <p>Common Use Cases: - Creating a \"ripple\" or \"cascade\" effect when animating the parts of a <code>VGroup</code>. - Making the appearance of multiple objects feel more organic and less robotic.</p> <p>When to Use: When you have many similar animations and want them to start one after another in quick succession, not all at once.</p>"},{"location":"animations/composition/#complete-signature_2","title":"Complete Signature","text":"<pre><code>LaggedStart(\n    *animations: Animation,\n    *,\n    lag_ratio: float = 0.05,\n    **kwargs\n)\n</code></pre>"},{"location":"animations/composition/#key-parameters_2","title":"Key Parameters","text":"<ul> <li><code>animations</code> (Animation): The animation objects to play.</li> <li><code>lag_ratio</code> (float): The delay between the start times of consecutive animations, as a fraction of one animation's duration. Default is <code>0.05</code>.</li> </ul> <p>Related: <code>AnimationGroup</code></p>"},{"location":"animations/creation/","title":"Creation","text":"<p>These animations are for bringing mobjects onto the screen.</p>"},{"location":"animations/creation/#create-showcreation","title":"<code>Create</code> / <code>ShowCreation</code>","text":"<p>Purpose: Draws a <code>VMobject</code> onto the screen, as if with a pen.</p> <p>Common Use Cases: - Drawing shapes like circles, squares, and lines. - Revealing graphs and paths.</p> <p>When to Use: When you want to show the \"drawing\" of a vector-based object. For text or formulas, <code>Write</code> is usually better.</p>"},{"location":"animations/creation/#complete-signature","title":"Complete Signature","text":"<pre><code>Create(\n    mobject: Mobject,\n    *,\n    run_time: float = 1.0,\n    lag_ratio: float = 1.0,\n    **kwargs\n) -&gt; Animation\n</code></pre>"},{"location":"animations/creation/#key-parameters","title":"Key Parameters","text":"<ul> <li><code>mobject</code> (Mobject): The <code>VMobject</code> to be created.</li> <li><code>lag_ratio</code> (float): If the mobject has parts, this controls the delay between drawing each part. A <code>lag_ratio</code> of <code>1.0</code> means parts are drawn sequentially. A <code>lag_ratio</code> of <code>0.0</code> means they are drawn simultaneously.</li> </ul> <p>Related: <code>Write</code>, <code>DrawBorderThenFill</code>, <code>Uncreate</code> (reverse animation)</p>"},{"location":"animations/creation/#write","title":"<code>Write</code>","text":"<p>Purpose: Animates the appearance of text or mathematical formulas in a way that looks like writing.</p> <p>Common Use Cases: - Revealing <code>Text</code>, <code>Tex</code>, or <code>MathTex</code> mobjects.</p> <p>When to Use: This is the standard animation for making text appear.</p>"},{"location":"animations/creation/#complete-signature_1","title":"Complete Signature","text":"<pre><code>Write(\n    vmobject: VMobject,\n    *,\n    run_time: float = -1,\n    lag_ratio: float = -1,\n    rate_func: Callable = linear,\n    **kwargs\n) -&gt; Animation\n</code></pre>"},{"location":"animations/creation/#key-parameters_1","title":"Key Parameters","text":"<ul> <li><code>vmobject</code> (<code>Text</code> or <code>Tex</code>): The text mobject to write.</li> <li><code>run_time</code> (float): If <code>-1</code>, the run time is automatically calculated based on the number of characters.</li> <li><code>lag_ratio</code> (float): If <code>-1</code>, the lag ratio is automatically calculated.</li> </ul> <p>Inherits from: <code>DrawBorderThenFill</code></p> <p>Related: <code>Create</code>, <code>AddTextWordByWord</code></p>"},{"location":"animations/fading/","title":"Fading","text":"<p>These animations control the visibility of mobjects.</p>"},{"location":"animations/fading/#fadein","title":"<code>FadeIn</code>","text":"<p>Purpose: Makes a mobject appear by smoothly increasing its opacity.</p> <p>Common Use Cases: - Introducing a new object to the scene without a drawing animation. - Making an object appear from a specific direction or scale.</p> <p>When to Use: When you want an object to simply \"appear\" rather than be drawn.</p>"},{"location":"animations/fading/#complete-signature","title":"Complete Signature","text":"<pre><code>FadeIn(\n    mobject: Mobject,\n    *,\n    shift: np.ndarray = ORIGIN,\n    scale: float = 1.0,\n    run_time: float = 1.0,\n    **kwargs\n) -&gt; Animation\n</code></pre>"},{"location":"animations/fading/#key-parameters","title":"Key Parameters","text":"<ul> <li><code>mobject</code> (Mobject): The mobject to fade in.</li> <li><code>shift</code> (Vect3): A vector indicating the direction from which the mobject should appear (e.g., <code>UP</code>, <code>DOWN</code>).</li> <li><code>scale</code> (float): The starting scale factor. A value less than 1 makes it grow as it fades in.</li> </ul> <p>Related: <code>FadeOut</code>, <code>Create</code></p>"},{"location":"animations/fading/#fadeout","title":"<code>FadeOut</code>","text":"<p>Purpose: Makes a mobject disappear by smoothly decreasing its opacity.</p> <p>Common Use Cases: - Removing an object from the scene. - Clearing space for new objects.</p> <p>When to Use: When you want an object to simply \"disappear\".</p>"},{"location":"animations/fading/#complete-signature_1","title":"Complete Signature","text":"<pre><code>FadeOut(\n    mobject: Mobject,\n    *,\n    shift: np.ndarray = ORIGIN,\n    scale: float = 1.0,\n    run_time: float = 1.0,\n    **kwargs\n) -&gt; Animation\n</code></pre>"},{"location":"animations/fading/#key-parameters_1","title":"Key Parameters","text":"<ul> <li><code>mobject</code> (Mobject): The mobject to fade out.</li> <li><code>shift</code> (Vect3): A vector indicating the direction towards which the mobject should move as it disappears.</li> <li><code>scale</code> (float): The final scale factor. A value less than 1 makes it shrink as it fades out.</li> </ul> <p>Related: <code>FadeIn</code>, <code>Uncreate</code></p>"},{"location":"animations/transformation/","title":"Transformation","text":"<p>These animations morph one mobject into another.</p>"},{"location":"animations/transformation/#transform","title":"<code>Transform</code>","text":"<p>Purpose: Smoothly transforms one mobject into the shape, position, and style of a target mobject.</p> <p>Common Use Cases: - Morphing one shape into another (e.g., a circle into a square). - Moving, scaling, and rotating a mobject to a new state in one smooth animation.</p> <p>When to Use: When you want to show a continuous change from a starting state to an ending state for the same conceptual object. The original mobject is modified in place.</p>"},{"location":"animations/transformation/#complete-signature","title":"Complete Signature","text":"<pre><code>Transform(\n    mobject: Mobject,\n    target_mobject: Mobject,\n    *,\n    run_time: float = 1.0,\n    path_arc: float = 0.0,\n    **kwargs\n) -&gt; Animation\n</code></pre>"},{"location":"animations/transformation/#key-parameters","title":"Key Parameters","text":"<ul> <li><code>mobject</code> (Mobject): The mobject to be transformed.</li> <li><code>target_mobject</code> (Mobject): A mobject defining the target state. The <code>mobject</code> will be modified to match this target.</li> <li><code>path_arc</code> (float): Angle in radians for arcing the path of the transformation.</li> </ul> <p>Related: <code>ReplacementTransform</code>, <code>ApplyMethod</code></p>"},{"location":"animations/transformation/#replacementtransform","title":"<code>ReplacementTransform</code>","text":"<p>Purpose: Transforms a starting mobject into a target mobject, then removes the starting mobject and adds the target mobject to the scene.</p> <p>Common Use Cases: - Showing an object being replaced by a new one (e.g., <code>f(x)</code> becomes <code>f'(x)</code>). - Morphing between two distinct objects where you want the final object to persist on screen.</p> <p>When to Use: - Use <code>ReplacementTransform</code> when the conceptual object changes (e.g., a variable <code>x</code> is replaced by the number <code>3</code>). - Use <code>Transform</code> when the conceptual object remains the same but its properties change (e.g., a square moves and changes color).</p>"},{"location":"animations/transformation/#complete-signature_1","title":"Complete Signature","text":"<pre><code>ReplacementTransform(\n    mobject: Mobject,\n    target_mobject: Mobject,\n    *,\n    run_time: float = 1.0,\n    **kwargs\n) -&gt; Animation\n</code></pre> <p>Inherits from: <code>Transform</code></p> <p>Related: <code>Transform</code></p>"},{"location":"mobjects/geometry/","title":"Geometry","text":"<p>These are the fundamental shapes used in Manim.</p>"},{"location":"mobjects/geometry/#circle","title":"<code>Circle</code>","text":"<p>Purpose: Creates a circle.</p> <p>Common Use Cases: - Representing circular objects or areas. - Used as a basis for other curved shapes. - Highlighting a specific point.</p> <p>When to Use: When you need a perfect circle. For ovals, use <code>Ellipse</code>.</p>"},{"location":"mobjects/geometry/#complete-signature","title":"Complete Signature","text":"<pre><code>Circle(\n    *,\n    radius: float = 1.0,\n    color: ManimColor = RED,\n    fill_color: ManimColor = None,\n    fill_opacity: float = 0.0,\n    stroke_color: ManimColor = None,\n    stroke_width: float = 4.0,\n    stroke_opacity: float = 1.0,\n    **kwargs\n)\n</code></pre>"},{"location":"mobjects/geometry/#key-parameters","title":"Key Parameters","text":"<ul> <li><code>radius</code> (float): The radius of the circle. Default: <code>1.0</code>.</li> <li><code>color</code> (ManimColor): A shorthand to set both <code>fill_color</code> and <code>stroke_color</code>. The default <code>RED</code> is a specific override for <code>Circle</code>.</li> <li><code>fill_opacity</code> (float): The opacity of the circle's interior, from 0 (transparent) to 1 (opaque). Default: <code>0.0</code>.</li> <li><code>stroke_width</code> (float): The thickness of the outline. Default: <code>4.0</code>.</li> </ul> <p>Inherits from: <code>VMobject</code></p> <p>Related: <code>Dot</code>, <code>Ellipse</code>, <code>Arc</code></p>"},{"location":"mobjects/geometry/#square","title":"<code>Square</code>","text":"<p>Purpose: Creates a square.</p> <p>Common Use Cases: - Representing boxes, grids, or nodes. - A fundamental building block for more complex diagrams.</p> <p>When to Use: When you need a rectangle with equal sides.</p>"},{"location":"mobjects/geometry/#complete-signature_1","title":"Complete Signature","text":"<pre><code>Square(\n    *,\n    side_length: float = 2.0,\n    color: ManimColor = DEFAULT_MOBJECT_COLOR,\n    fill_color: ManimColor = None,\n    fill_opacity: float = 0.0,\n    stroke_color: ManimColor = None,\n    stroke_width: float = 4.0,\n    stroke_opacity: float = 1.0,\n    **kwargs\n)\n</code></pre>"},{"location":"mobjects/geometry/#key-parameters_1","title":"Key Parameters","text":"<ul> <li><code>side_length</code> (float): The length of each side of the square. Default: <code>2.0</code>.</li> </ul> <p>Inherits from: <code>Rectangle</code></p> <p>Related: <code>Rectangle</code>, <code>Polygon</code></p>"},{"location":"mobjects/geometry/#rectangle","title":"<code>Rectangle</code>","text":"<p>Purpose: Creates a rectangle.</p> <p>Common Use Cases: - Framing content (<code>SurroundingRectangle</code>). - Creating UI elements like buttons or panels. - Representing rectangular areas in diagrams.</p> <p>When to Use: For any four-sided shape with 90-degree angles where width and height may differ.</p>"},{"location":"mobjects/geometry/#complete-signature_2","title":"Complete Signature","text":"<pre><code>Rectangle(\n    *,\n    width: float = 4.0,\n    height: float = 2.0,\n    color: ManimColor = DEFAULT_MOBJECT_COLOR,\n    fill_color: ManimColor = None,\n    fill_opacity: float = 0.0,\n    stroke_color: ManimColor = None,\n    stroke_width: float = 4.0,\n    stroke_opacity: float = 1.0,\n    **kwargs\n)\n</code></pre>"},{"location":"mobjects/geometry/#key-parameters_2","title":"Key Parameters","text":"<ul> <li><code>width</code> (float): The width of the rectangle. Default: <code>4.0</code>.</li> <li><code>height</code> (float): The height of the rectangle. Default: <code>2.0</code>.</li> </ul> <p>Inherits from: <code>Polygon</code></p> <p>Related: <code>Square</code>, <code>SurroundingRectangle</code></p>"},{"location":"mobjects/geometry/#line","title":"<code>Line</code>","text":"<p>Purpose: Creates a straight or curved line segment between two points.</p> <p>Common Use Cases: - Connecting two objects. - Forming the axes of a graph. - Drawing diagrams and paths.</p> <p>When to Use: To draw a connection between a start and end point.</p>"},{"location":"mobjects/geometry/#complete-signature_3","title":"Complete Signature","text":"<pre><code>Line(\n    start: Vect3 | Mobject = LEFT,\n    end: Vect3 | Mobject = RIGHT,\n    *,\n    buff: float = 0.0,\n    path_arc: float = 0.0,\n    stroke_color: ManimColor = DEFAULT_VMOBJECT_STROKE_COLOR,\n    stroke_width: float = 4.0,\n    **kwargs\n)\n</code></pre>"},{"location":"mobjects/geometry/#key-parameters_3","title":"Key Parameters","text":"<ul> <li><code>start</code> (Vect3 | Mobject): The starting point of the line. Can be a coordinate (like <code>LEFT</code> or <code>[1, 2, 0]</code>) or a mobject (connects to its center).</li> <li><code>end</code> (Vect3 | Mobject): The ending point of the line.</li> <li><code>buff</code> (float): Shortens the line at both ends by this amount.</li> <li><code>path_arc</code> (float): The angle in radians to curve the line. <code>0</code> creates a straight line. A positive value curves counter-clockwise.</li> </ul>"},{"location":"mobjects/geometry/#key-methods","title":"Key Methods","text":"<pre><code>get_vector(self) -&gt; Vect3\n</code></pre> <p>Returns the vector from the start to the end of the line.</p> <pre><code>get_angle(self) -&gt; float\n</code></pre> <p>Returns the angle of the line with respect to the positive x-axis.</p> <p>Inherits from: <code>VMobject</code></p> <p>Related: <code>Arrow</code>, <code>DashedLine</code>, <code>Arc</code></p>"},{"location":"mobjects/geometry/#arrow","title":"<code>Arrow</code>","text":"<p>Purpose: Creates a line with a triangular tip at the end.</p> <p>Common Use Cases: - Indicating direction or flow (vectors). - Pointing from one object to another. - Annotating diagrams.</p> <p>When to Use: When you need a <code>Line</code> that shows direction.</p>"},{"location":"mobjects/geometry/#complete-signature_4","title":"Complete Signature","text":"<pre><code>Arrow(\n    start: Vect3 | Mobject = LEFT,\n    end: Vect3 | Mobject = RIGHT,\n    *,\n    buff: float = MED_SMALL_BUFF,\n    thickness: float = 3.0,\n    tip_width_ratio: float = 5,\n    **kwargs\n)\n</code></pre>"},{"location":"mobjects/geometry/#key-parameters_4","title":"Key Parameters","text":"<ul> <li><code>start</code> (Vect3 | Mobject): The starting point of the arrow's shaft.</li> <li><code>end</code> (Vect3 | Mobject): The point the arrow's tip points to.</li> <li><code>buff</code> (float): Buffer space between the start/end points and the actual start/end of the arrow.</li> <li><code>thickness</code> (float): Controls the width of the arrow's shaft.</li> </ul> <p>Inherits from: <code>Line</code></p> <p>Related: <code>Line</code>, <code>Vector</code></p>"},{"location":"mobjects/geometry/#dot","title":"<code>Dot</code>","text":"<p>Purpose: Creates a small, filled circle.</p> <p>Common Use Cases: - Marking points on a graph or diagram. - Representing particles or discrete items.</p> <p>When to Use: For a small, solid circular marker. For a hollow circle, use <code>Circle</code>.</p>"},{"location":"mobjects/geometry/#complete-signature_5","title":"Complete Signature","text":"<pre><code>Dot(\n    point: Vect3 = ORIGIN,\n    *,\n    radius: float = DEFAULT_DOT_RADIUS,\n    color: ManimColor = DEFAULT_MOBJECT_COLOR,\n    **kwargs\n)\n</code></pre>"},{"location":"mobjects/geometry/#key-parameters_5","title":"Key Parameters","text":"<ul> <li><code>point</code> (Vect3): The center of the dot.</li> <li><code>radius</code> (float): The radius of the dot.</li> <li><code>color</code> (ManimColor): The fill color of the dot.</li> </ul> <p>Inherits from: <code>Circle</code></p> <p>Related: <code>Circle</code>, <code>SmallDot</code></p>"},{"location":"mobjects/grouping/","title":"Grouping","text":""},{"location":"mobjects/grouping/#vgroup","title":"<code>VGroup</code>","text":"<p>Purpose: Groups multiple <code>VMobject</code>s together so they can be treated as a single unit.</p> <p>Common Use Cases: - Applying transformations (like <code>shift</code>, <code>scale</code>, <code>rotate</code>) to multiple objects at once. - Animating a collection of objects with <code>LaggedStart</code>. - Organizing complex scenes.</p> <p>When to Use: Any time you have a collection of shapes, lines, or text that should logically stick together and be manipulated as one. For non-vectorized mobjects, use <code>Group</code>.</p>"},{"location":"mobjects/grouping/#complete-signature","title":"Complete Signature","text":"<pre><code>VGroup(\n    *vmobjects: VMobject,\n    **kwargs\n)\n</code></pre>"},{"location":"mobjects/grouping/#key-parameters","title":"Key Parameters","text":"<ul> <li><code>vmobjects</code> (VMobject): The <code>VMobject</code>s to include in the group.</li> </ul>"},{"location":"mobjects/grouping/#key-methods","title":"Key Methods","text":"<pre><code>arrange(self, direction: Vect3 = RIGHT, center: bool = True, **kwargs) -&gt; Self\n</code></pre> <p>Arranges submobjects in a line along the specified <code>direction</code>.</p> <p>Inherits from: <code>VMobject</code>, <code>Group</code></p> <p>Related: <code>Group</code></p>"},{"location":"mobjects/text-math/","title":"Text &amp; Math","text":"<p>Manim provides powerful tools for rendering text and mathematical equations using either Pango (for plain text) or a full LaTeX installation (for math).</p>"},{"location":"mobjects/text-math/#text","title":"<code>Text</code>","text":"<p>Purpose: Renders plain text strings quickly using the Pango library.</p> <p>Common Use Cases: - Displaying titles, labels, and sentences. - Any text that does not require mathematical typesetting.</p> <p>When to Use: Use for all non-mathematical text. It's much faster to render than <code>Tex</code>. For math, use <code>Tex</code> or <code>MathTex</code>.</p>"},{"location":"mobjects/text-math/#complete-signature","title":"Complete Signature","text":"<pre><code>Text(\n    text: str,\n    *,\n    font: str = \"\",\n    font_size: int = 48,\n    color: ManimColor = DEFAULT_MOBJECT_COLOR,\n    **kwargs\n)\n</code></pre>"},{"location":"mobjects/text-math/#key-parameters","title":"Key Parameters","text":"<ul> <li><code>text</code> (str): The string to be rendered.</li> <li><code>font</code> (str): The font family to use (e.g., \"Arial\", \"Consolas\").</li> <li><code>font_size</code> (int): The font size.</li> <li><code>color</code> (ManimColor): The color of the text.</li> </ul> <p>Related: <code>Tex</code>, <code>MathTex</code></p>"},{"location":"mobjects/text-math/#tex-mathtex","title":"<code>Tex</code> / <code>MathTex</code>","text":"<p>Purpose: Renders strings using a LaTeX installation, ideal for mathematical formulas and symbols.</p> <p>Common Use Cases: - Displaying complex mathematical equations. - Using specific LaTeX symbols or packages. - Typesetting text with the quality of LaTeX.</p> <p>When to Use: When you need to display anything with mathematical notation. <code>MathTex</code> is a convenient alias that automatically wraps the string in a math environment.</p>"},{"location":"mobjects/text-math/#comparison","title":"Comparison","text":"<ul> <li><code>Text</code>: Fast, uses Pango, for plain text. Cannot render LaTeX math.</li> <li><code>Tex</code> / <code>MathTex</code>: Slower, requires a full LaTeX installation, for high-quality math and text typesetting.</li> </ul>"},{"location":"mobjects/text-math/#complete-signature_1","title":"Complete Signature","text":"<pre><code>Tex(\n    *tex_strings: str,\n    font_size: int = 48,\n    color: ManimColor = DEFAULT_MOBJECT_COLOR,\n    isolate: Selector = [],\n    tex_to_color_map: dict = {},\n    **kwargs\n)\n</code></pre>"},{"location":"mobjects/text-math/#key-parameters_1","title":"Key Parameters","text":"<ul> <li><code>tex_strings</code> (str): One or more strings to be rendered. They will be concatenated.</li> <li><code>font_size</code> (int): The font size.</li> <li><code>isolate</code> (list): A list of substrings to treat as separate mobjects, allowing them to be colored or animated independently.</li> <li><code>tex_to_color_map</code> (dict): A dictionary mapping substrings to colors (e.g., <code>{\"x\": RED}</code>).</li> </ul> <p>Related: <code>Text</code>, <code>SingleStringMathTex</code></p>"},{"location":"mobjects/utilities/","title":"Utilities","text":""},{"location":"mobjects/utilities/#valuetracker","title":"<code>ValueTracker</code>","text":"<p>Purpose: A container for a numerical value that can be animated and tracked. It is not visible on screen.</p> <p>Common Use Cases: - Driving animations that depend on a changing parameter. - Creating updaters that link one mobject's properties to the value of the <code>ValueTracker</code>. - Animating a number changing over time.</p> <p>When to Use: When you need to animate a parameter itself, not just a mobject's properties. For example, to smoothly change the angle of a line in an animation, you would animate a <code>ValueTracker</code> for the angle and use an updater to apply that angle to the line.</p>"},{"location":"mobjects/utilities/#complete-signature","title":"Complete Signature","text":"<pre><code>ValueTracker(\n    value: float | complex | np.ndarray = 0,\n    **kwargs\n)\n</code></pre>"},{"location":"mobjects/utilities/#key-methods","title":"Key Methods","text":"<pre><code>get_value(self) -&gt; float | complex | np.ndarray\n</code></pre> <p>Returns the current value.</p> <pre><code>set_value(self, value: float | complex | np.ndarray) -&gt; Self\n</code></pre> <p>Sets the current value.</p>"},{"location":"mobjects/utilities/#example-pattern","title":"Example Pattern","text":"<pre><code># In your construct method:\nvalue = ValueTracker(0)\nline = Line(LEFT, RIGHT)\nline.add_updater(lambda m: m.set_angle(value.get_value()))\nself.play(value.animate.set_value(PI / 2))\n</code></pre> <p>Inherits from: <code>Mobject</code></p>"}]}